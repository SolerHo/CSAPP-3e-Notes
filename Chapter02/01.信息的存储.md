# 一、信息的存储

大多数计算机使用 `8位` 的块，或者是`字节（byte）` ，作为最小的可寻址的内存单元。而不是访问内存中单独的位。


**虚拟内存（virtual memory）**：机器级程序把内存看作一个大的字节数组。

**地址（address）**：内存每一个字节都有唯一的数字标识。所有可能地址的集合叫做**虚拟地址空间（virtual address space）**。

**程序对象（program object）**：程序数据、指令和控制信息。

## 十六进制表示法
一个字节 = 8位

十六进制（简写为：hex）：以16作为基数，或者叫做`十六进制（hexadecimal）数`，来表示位模式。

使用`数字 0 ～ 9` 以及 `字符 A ～ F` 来表示16个可能的值。

![](https://github.com/SolerHo/CSAPP-3e-Notes/blob/master/Chapter02/Images/%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA.png)

在C语言中，以 `0x` 或者 `0X` 开头的数字常量就被认为是十六进制数。

字符 `A ~ F` ，大小写都可以。

对于十六进制转换为二进制格式，我们可以展开每个十六进制数字，然后转换为二进制格式。

编写机器级程序的一个常见的任务：在` 位模式` 的十进制、二进制和十六进制表示之间人工转换。

例子：将`0x173A4C ` 转换为二进制格式
|十六进制|1|7|3|A|4|C|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|二进制|0001|0111|0011|1010|0100|1100|

二进制转换为十六进制时，每4位为一组，然后转换为十六进制数。


#### 十进制和十六进制之间的转换
较大数值的十进制和十六进制之间的转换，最好是让计算机或者计算器来完成。

最简单的方法：利用任何标准的搜索引擎。

## 字数据大小
**字长（word size）**：指明指针数据的**标称大小（normal size）**。

字长决定最重要的系统参数：虚拟空间的最大大小。


如果机器的字长为w，则虚拟地址的范围为 `0 ~ 2^w-1`，程序最多访问`2^w`个字节。

大部分数据类型都编码为有符号数值，除非有`前缀关键字unsigned`或`确定大小`的数据类型使用了特定的`无符号声明`。

注意点：**char数据类型除外**。


## 寻址和字节顺序
`多字节对象`都被存储为`连续`的`字节序列`，对象的`地址`为所使用字节中`最小的地址`。

排列表示一个对象的字节有两个通用的规则。

![](https://github.com/SolerHo/CSAPP-3e-Notes/blob/master/Chapter02/Images/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%B3%95.png)

- **大端法（big endian）**：最高有效字节在最前面的方式
- **小端法（little endian）**：最低有效字节在最前面的方式

大多数的Intel兼容机都只是小端模式。

IBM和Oracle的大多数机器则是按大端模式操作。（当然了，它们制造的PC兼容的intel的处理器，也使用到了小端法）


许多比较新的微处理器是**双端法（bi-endian）**，就是配置成大端或小端的机器进行运行。

实际情况下，如果操作系统的确定，那么字节的顺序也随之固定。


目前最常见的`Android`和`IOS`系统，都只是运行于`小端模式`。

对于应用级的程序员来说，机器所使用的`字节顺序是不可见`的。

**反编译器（disassemble）**：是一种确定`可执行程序文件`所表示的`指令序列`的工具。


## 表示代码
机器的`指令编码`是不同的，不同的`机器类型`使用不同的且`不兼容的指令和编码方式`。

由于不同的OS也有不同的`编码规则`，所以说`二进制是不兼容`的。（二进制在机器和OS组合的可移植性差）

从`机器的角度`来说，`程序`仅仅只是`字节序列`。




## 布尔代数简介
`二进制值（0和1）`是计算机`编码`、`存储`和`操作`信息的`核心`。

布尔代数（Boolean Algebra）：起源于1850钱前后乔治·布尔(George Boole)

通过逻辑值`TRUE（真）`和`FALSE（假）`编码为`二进制1和0`，设计出一种代数，以研究逻辑推理的基本原则。

|布尔运算符|逻辑运算|解释|集合|
|:--:|:--:|:--|:--|
|`~`|NOT|非|补集|
|`&`|AND|和|交集|
|`|`|OR|或|并集|
|`^`|Exclusive-OR|异或|

![](https://github.com/SolerHo/CSAPP-3e-Notes/blob/master/Chapter02/Images/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E8%BF%90%E7%AE%97.png)

#### 布尔运算的分配率
- a & (b | c) = (a & b)|(a & c),
- a | (b & c) = (a | b)&(a | c)

另外，对于a ^ a = 0，因此还有(a ^ b) ^ a = b

## 移位运算
C语言提供了一组移位运算：`向左`或`向右`移动`位`模式。

#### 向左移位
x向左移动 `k` 位，`丢弃`最高的 `k `位，并在`右端补k个0`。

一般来说，机器支持两种形式的右移：**逻辑右移** 和 **算术右移**。

- 逻辑右移：在左端补k个0。
- 算术右移：在左端补k个最高有效位的值。

#### 注意点
对于无符号数，右移必须是逻辑的。

加减法的优先级高于移位运算符的优先级。

#### 对位运算的说明
C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移。

与C相比，java对于右移有明确的定义。
- 表达式x>>K：会将x算术右移k个位置。
- 表达式x>>>k：会对x做逻辑右移。
